#import "InputParser.h"
#import "EnrichedAttributedStringHTMLSerializer.h"
#import "EnrichedTextInputView.h"
#import "StringExtension.h"
#import "StyleHeaders.h"
#import "TextInsertionUtils.h"
#import "UIView+React.h"

@implementation InputParser {
  EnrichedTextInputView *_input;
  EnrichedAttributedStringHTMLSerializer *_attributedStringHTMLSerializer;
}

- (instancetype)initWithInput:(id)input {
  self = [super init];
  _input = (EnrichedTextInputView *)input;
  _attributedStringHTMLSerializer =
      [[EnrichedAttributedStringHTMLSerializer alloc]
          initWithStyles:_input->stylesDict];
  return self;
}

- (NSString *)parseToHtmlFromRange:(NSRange)range {
  NSAttributedString *sub =
      [_input->textView.textStorage attributedSubstringFromRange:range];

  return [_attributedStringHTMLSerializer buildHtmlFromAttributedString:sub
                                                                pretify:YES];
}

- (void)replaceWholeFromHtml:(NSString *_Nonnull)html {
  NSArray *processingResult = [self getTextAndStylesFromHtml:html];
  NSString *plainText = (NSString *)processingResult[0];
  NSArray *stylesInfo = (NSArray *)processingResult[1];

  // reset the text first and reset typing attributes
  _input->textView.text = @"";
  _input->textView.typingAttributes = _input->defaultTypingAttributes;

  // set new text
  _input->textView.text = plainText;

  // re-apply the styles
  [self applyProcessedStyles:stylesInfo
         offsetFromBeginning:0
             plainTextLength:plainText.length];
}

- (void)replaceFromHtml:(NSString *_Nonnull)html range:(NSRange)range {
  NSArray *processingResult = [self getTextAndStylesFromHtml:html];
  NSString *plainText = (NSString *)processingResult[0];
  NSArray *stylesInfo = (NSArray *)processingResult[1];

  // we can use ready replace util
  [TextInsertionUtils replaceText:plainText
                               at:range
             additionalAttributes:nil
                            input:_input
                    withSelection:YES];

  [self applyProcessedStyles:stylesInfo
         offsetFromBeginning:range.location
             plainTextLength:plainText.length];
}

- (void)insertFromHtml:(NSString *_Nonnull)html location:(NSInteger)location {
  NSArray *processingResult = [self getTextAndStylesFromHtml:html];
  NSString *plainText = (NSString *)processingResult[0];
  NSArray *stylesInfo = (NSArray *)processingResult[1];

  // same here, insertion utils got our back
  [TextInsertionUtils insertText:plainText
                              at:location
            additionalAttributes:nil
                           input:_input
                   withSelection:YES];

  [self applyProcessedStyles:stylesInfo
         offsetFromBeginning:location
             plainTextLength:plainText.length];
}

- (void)applyProcessedStyles:(NSArray *)processedStyles
         offsetFromBeginning:(NSInteger)offset
             plainTextLength:(NSInteger)plainTextLength {
  for (NSArray *processedStyle in processedStyles) {
    // unwrap all info from processed style
    NSNumber *styleType = (NSNumber *)processedStyle[0];
    StylePair *stylePair = (StylePair *)processedStyle[1];
    id<BaseStyleProtocol> baseStyle = _input->stylesDict[styleType];
    // range must be taking offest into consideration because processed styles'
    // ranges are relative to only the new text while we need absolute ranges
    // relative to the whole existing text
    NSRange styleRange =
        NSMakeRange(offset + [stylePair.rangeValue rangeValue].location,
                    [stylePair.rangeValue rangeValue].length);

    // of course any changes here need to take blocks and conflicts into
    // consideration
    if ([_input handleStyleBlocksAndConflicts:[[baseStyle class] getStyleType]
                                        range:styleRange]) {
      if ([styleType isEqualToNumber:@([LinkStyle getStyleType])]) {
        NSString *text =
            [_input->textView.textStorage.string substringWithRange:styleRange];
        NSString *url = (NSString *)stylePair.styleValue;
        BOOL isManual = ![text isEqualToString:url];
        [((LinkStyle *)baseStyle) addLink:text
                                      url:url
                                    range:styleRange
                                   manual:isManual];
      } else if ([styleType isEqualToNumber:@([MentionStyle getStyleType])]) {
        MentionParams *params = (MentionParams *)stylePair.styleValue;
        [((MentionStyle *)baseStyle) addMentionAtRange:styleRange
                                                params:params];
      } else if ([styleType isEqualToNumber:@([ImageStyle getStyleType])]) {
        ImageData *imgData = (ImageData *)stylePair.styleValue;
        [((ImageStyle *)baseStyle) addImageAtRange:styleRange
                                         imageData:imgData
                                     withSelection:NO];
      } else if ([styleType isEqualToNumber:@([CheckBoxStyle getStyleType])]) {
        BOOL isChecked = [stylePair.styleValue boolValue];
        [((CheckBoxStyle *)baseStyle) addCheckBoxAtRange:styleRange
                                               isChecked:isChecked
                                          withTypingAttr:NO];
      } else if ([styleType isEqualToNumber:@([ColorStyle getStyleType])]) {
        UIColor *color = (UIColor *)stylePair.styleValue;
        [((ColorStyle *)baseStyle) applyStyle:styleRange color:color];
      } else if ([styleType isEqualToNumber:@([ContentStyle getStyleType])]) {
        ContentParams *cparams = (ContentParams *)stylePair.styleValue;
        [((ContentStyle *)baseStyle) addContentAtRange:styleRange
                                                params:cparams];
      } else {
        BOOL shouldAddTypingAttr =
            styleRange.location + styleRange.length == plainTextLength;
        [baseStyle addAttributes:styleRange withTypingAttr:shouldAddTypingAttr];
      }
    }
  }
  [_input anyTextMayHaveBeenModified];
}

- (NSString *_Nullable)initiallyProcessHtml:(NSString *_Nonnull)html {
  NSString *fixedHtml = nullptr;

  if (html.length >= 13) {
    NSString *firstSix = [html substringWithRange:NSMakeRange(0, 6)];
    NSString *lastSeven =
        [html substringWithRange:NSMakeRange(html.length - 7, 7)];

    if ([firstSix isEqualToString:@"<html>"] &&
        [lastSeven isEqualToString:@"</html>"]) {
      // remove html tags, might be with newlines or without them
      fixedHtml = [html copy];
      // firstly remove newlined html tags if any:
      fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<html>\n"
                                                       withString:@""];
      fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"\n</html>"
                                                       withString:@""];
      // fallback; remove html tags without their newlines
      fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<html>"
                                                       withString:@""];
      fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"</html>"
                                                       withString:@""];
    } else {
      // in other case we are most likely working with some external html - try
      // getting the styles from between body tags
      NSRange openingBodyRange = [html rangeOfString:@"<body>"];
      NSRange closingBodyRange = [html rangeOfString:@"</body>"];

      if (openingBodyRange.length != 0 && closingBodyRange.length != 0) {
        NSInteger newStart = openingBodyRange.location + 7;
        NSInteger newEnd = closingBodyRange.location - 1;
        fixedHtml = [html
            substringWithRange:NSMakeRange(newStart, newEnd - newStart + 1)];
      }
    }
  }

  // second processing - try fixing htmls with wrong newlines' setup
  if (fixedHtml != nullptr) {
    // add <br> tag wherever needed
    fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<p></p>"
                                                     withString:@"<br>"];

    // remove <p> tags inside of <li>
    fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"<li><p>"
                                                     withString:@"<li>"];
    fixedHtml = [fixedHtml stringByReplacingOccurrencesOfString:@"</p></li>"
                                                     withString:@"</li>"];

    // tags that have to be in separate lines
    fixedHtml = [self stringByAddingNewlinesToTag:@"<br>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<ul>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"</ul>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<ol>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"</ol>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<blockquote>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"</blockquote>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<codeblock>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"</codeblock>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<hr>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<hr/>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<content>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<content/>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:YES];

    // line opening tags
    fixedHtml = [self stringByAddingNewlinesToTag:@"<p>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:NO];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<li>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:NO];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<h1>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:NO];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<h2>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:NO];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<h3>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:NO];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<h4>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:NO];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<h5>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:NO];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<h6>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:NO];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<checklist>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:NO];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<content>"
                                         inString:fixedHtml
                                          leading:YES
                                         trailing:NO];

    // line closing tags
    fixedHtml = [self stringByAddingNewlinesToTag:@"</p>"
                                         inString:fixedHtml
                                          leading:NO
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"</li>"
                                         inString:fixedHtml
                                          leading:NO
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"</h1>"
                                         inString:fixedHtml
                                          leading:NO
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"</h2>"
                                         inString:fixedHtml
                                          leading:NO
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"</h3>"
                                         inString:fixedHtml
                                          leading:NO
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"</h4>"
                                         inString:fixedHtml
                                          leading:NO
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"</h5>"
                                         inString:fixedHtml
                                          leading:NO
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"</h6>"
                                         inString:fixedHtml
                                          leading:NO
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"</checklist>"
                                         inString:fixedHtml
                                          leading:NO
                                         trailing:YES];
    fixedHtml = [self stringByAddingNewlinesToTag:@"<content>"
                                         inString:fixedHtml
                                          leading:NO
                                         trailing:NO];
  }

  return fixedHtml;
}

- (NSString *)stringByAddingNewlinesToTag:(NSString *)tag
                                 inString:(NSString *)html
                                  leading:(BOOL)leading
                                 trailing:(BOOL)trailing {
  NSString *str = [html copy];
  if (leading) {
    NSString *formattedTag = [NSString stringWithFormat:@">%@", tag];
    NSString *formattedNewTag = [NSString stringWithFormat:@">\n%@", tag];
    str = [str stringByReplacingOccurrencesOfString:formattedTag
                                         withString:formattedNewTag];
  }
  if (trailing) {
    NSString *formattedTag = [NSString stringWithFormat:@"%@<", tag];
    NSString *formattedNewTag = [NSString stringWithFormat:@"%@\n<", tag];
    str = [str stringByReplacingOccurrencesOfString:formattedTag
                                         withString:formattedNewTag];
  }
  return str;
}

- (void)finalizeTagEntry:(NSMutableString *)tagName
               ongoingTags:(NSMutableDictionary *)ongoingTags
    initiallyProcessedTags:(NSMutableArray *)processedTags
                 plainText:(NSMutableString *)plainText {
  NSMutableArray *tagEntry = [[NSMutableArray alloc] init];

  NSArray *tagData = ongoingTags[tagName];
  NSInteger tagLocation = [((NSNumber *)tagData[0]) intValue];
  NSRange tagRange = NSMakeRange(tagLocation, plainText.length - tagLocation);

  [tagEntry addObject:[tagName copy]];
  [tagEntry addObject:[NSValue valueWithRange:tagRange]];
  if (tagData.count > 1) {
    [tagEntry addObject:[(NSString *)tagData[1] copy]];
  }

  [processedTags addObject:tagEntry];
  [ongoingTags removeObjectForKey:tagName];
}

- (NSArray *)getTextAndStylesFromHtml:(NSString *)fixedHtml {
  NSMutableString *plainText = [[NSMutableString alloc] initWithString:@""];
  NSMutableDictionary *ongoingTags = [[NSMutableDictionary alloc] init];
  NSMutableArray *initiallyProcessedTags = [[NSMutableArray alloc] init];
  BOOL insideTag = NO;
  BOOL gettingTagName = NO;
  BOOL gettingTagParams = NO;
  BOOL closingTag = NO;
  NSMutableString *currentTagName =
      [[NSMutableString alloc] initWithString:@""];
  NSMutableString *currentTagParams =
      [[NSMutableString alloc] initWithString:@""];
  NSDictionary *htmlEntitiesDict =
      [NSString getEscapedCharactersInfoFrom:fixedHtml];

  // firstly, extract text and initially processed tags
  for (int i = 0; i < fixedHtml.length; i++) {
    NSString *currentCharacterStr =
        [fixedHtml substringWithRange:NSMakeRange(i, 1)];
    unichar currentCharacterChar = [fixedHtml characterAtIndex:i];

    if (currentCharacterChar == '<') {
      // opening the tag, mark that we are inside and getting its name
      insideTag = YES;
      gettingTagName = YES;
    } else if (currentCharacterChar == '>') {
      // finishing some tag, no longer marked as inside or getting its
      // name/params
      insideTag = NO;
      gettingTagName = NO;
      gettingTagParams = NO;

      if ([currentTagName isEqualToString:@"content"]) {
        [plainText appendFormat:@"%C", 0xFFFC];
        NSMutableArray *tagEntry = [[NSMutableArray alloc] init];
        NSRange tagRange = NSMakeRange(plainText.length - 1, 1);
        [tagEntry addObject:@"content"];
        [tagEntry addObject:[NSValue valueWithRange:tagRange]];
        if (currentTagParams.length > 0) {
          [tagEntry addObject:[currentTagParams copy]];
        }
        [initiallyProcessedTags addObject:tagEntry];

        // reset
        closingTag = NO;
        insideTag = NO;
        gettingTagName = NO;
        gettingTagParams = NO;
        currentTagName = [[NSMutableString alloc] initWithString:@""];
        currentTagParams = [[NSMutableString alloc] initWithString:@""];
        continue;
      }

      BOOL isSelfClosing = NO;

      // Check if params ended with '/' (e.g. <img src="" />)
      if ([currentTagParams hasSuffix:@"/"]) {
        [currentTagParams
            deleteCharactersInRange:NSMakeRange(currentTagParams.length - 1,
                                                1)];
        isSelfClosing = YES;
      }

      if ([currentTagName isEqualToString:@"hr"]) {
        // Insert divider character into the text
        [plainText appendFormat:@"%C", 0xFFFC];

        NSMutableArray *tagEntry = [[NSMutableArray alloc] init];

        NSRange tagRange = NSMakeRange(plainText.length - 1, 1);

        [tagEntry addObject:@"hr"];
        [tagEntry addObject:[NSValue valueWithRange:tagRange]];

        if (currentTagParams.length > 0) {
          [tagEntry addObject:[currentTagParams copy]];
        }

        [initiallyProcessedTags addObject:tagEntry];

        closingTag = NO;
        insideTag = NO;
        gettingTagName = NO;
        gettingTagParams = NO;
        currentTagName = [[NSMutableString alloc] initWithString:@""];
        currentTagParams = [[NSMutableString alloc] initWithString:@""];
        continue;
      }

      if ([currentTagName isEqualToString:@"p"] ||
          [currentTagName isEqualToString:@"br"] ||
          [currentTagName isEqualToString:@"li"]) {
        // do nothing, we don't include these tags in styles
      } else if (!closingTag) {
        // we finish opening tag - get its location and optionally params and
        // put them under tag name key in ongoingTags
        NSMutableArray *tagArr = [[NSMutableArray alloc] init];
        [tagArr addObject:[NSNumber numberWithInteger:plainText.length]];
        if (currentTagParams.length > 0) {
          [tagArr addObject:[currentTagParams copy]];
        }
        ongoingTags[currentTagName] = tagArr;

        // skip one newline after opening tags that are in separate lines
        // intentionally
        if ([currentTagName isEqualToString:@"ul"] ||
            [currentTagName isEqualToString:@"ol"] ||
            [currentTagName isEqualToString:@"blockquote"] ||
            [currentTagName isEqualToString:@"codeblock"]) {
          i += 1;
        }

        if (isSelfClosing) {
          [self finalizeTagEntry:currentTagName
                         ongoingTags:ongoingTags
              initiallyProcessedTags:initiallyProcessedTags
                           plainText:plainText];
        }
      } else {
        // we finish closing tags - pack tag name, tag range and optionally tag
        // params into an entry that goes inside initiallyProcessedTags

        // skip one newline that was added before some closing tags that are in
        // separate lines
        if ([currentTagName isEqualToString:@"ul"] ||
            [currentTagName isEqualToString:@"ol"] ||
            [currentTagName isEqualToString:@"blockquote"] ||
            [currentTagName isEqualToString:@"codeblock"]) {
          plainText = [[plainText
              substringWithRange:NSMakeRange(0, plainText.length - 1)]
              mutableCopy];
        }

        [self finalizeTagEntry:currentTagName
                       ongoingTags:ongoingTags
            initiallyProcessedTags:initiallyProcessedTags
                         plainText:plainText];
      }
      // post-tag cleanup
      closingTag = NO;
      currentTagName = [[NSMutableString alloc] initWithString:@""];
      currentTagParams = [[NSMutableString alloc] initWithString:@""];
    } else {
      if (!insideTag) {
        // no tags logic - just append the right text

        // html entity on the index; use unescaped character and forward
        // iterator accordingly
        NSArray *entityInfo = htmlEntitiesDict[@(i)];
        if (entityInfo != nullptr) {
          NSString *escaped = entityInfo[0];
          NSString *unescaped = entityInfo[1];
          [plainText appendString:unescaped];
          // the iterator will forward by 1 itself
          i += escaped.length - 1;
        } else {
          [plainText appendString:currentCharacterStr];
        }
      } else {
        if (gettingTagName) {
          if (currentCharacterChar == ' ') {
            // no longer getting tag name - switch to params
            gettingTagName = NO;
            gettingTagParams = YES;
          } else if (currentCharacterChar == '/') {
            // mark that the tag is closing
            closingTag = YES;
          } else {
            // append next tag char
            [currentTagName appendString:currentCharacterStr];
          }
        } else if (gettingTagParams) {
          // append next tag params char
          [currentTagParams appendString:currentCharacterStr];
        }
      }
    }
  }

  // process tags into proper StyleType + StylePair values
  NSMutableArray *processedStyles = [[NSMutableArray alloc] init];

  for (NSArray *arr in initiallyProcessedTags) {
    NSString *tagName = (NSString *)arr[0];
    NSValue *tagRangeValue = (NSValue *)arr[1];
    NSMutableString *params = [[NSMutableString alloc] initWithString:@""];
    if (arr.count > 2) {
      [params appendString:(NSString *)arr[2]];
    }

    NSMutableArray *styleArr = [[NSMutableArray alloc] init];
    StylePair *stylePair = [[StylePair alloc] init];
    if ([tagName isEqualToString:@"b"]) {
      [styleArr addObject:@([BoldStyle getStyleType])];
    } else if ([tagName isEqualToString:@"i"]) {
      [styleArr addObject:@([ItalicStyle getStyleType])];
    } else if ([tagName isEqualToString:@"img"]) {
      NSRegularExpression *srcRegex =
          [NSRegularExpression regularExpressionWithPattern:@"src=\"([^\"]+)\""
                                                    options:0
                                                      error:nullptr];
      NSTextCheckingResult *match =
          [srcRegex firstMatchInString:params
                               options:0
                                 range:NSMakeRange(0, params.length)];

      if (match == nullptr) {
        continue;
      }

      NSRange srcRange = match.range;
      [styleArr addObject:@([ImageStyle getStyleType])];
      // cut only the uri from the src="..." string
      NSString *uri =
          [params substringWithRange:NSMakeRange(srcRange.location + 5,
                                                 srcRange.length - 6)];
      ImageData *imageData = [[ImageData alloc] init];
      imageData.uri = uri;

      NSRegularExpression *widthRegex = [NSRegularExpression
          regularExpressionWithPattern:@"width=\"([0-9.]+)\""
                               options:0
                                 error:nil];
      NSTextCheckingResult *widthMatch =
          [widthRegex firstMatchInString:params
                                 options:0
                                   range:NSMakeRange(0, params.length)];

      if (widthMatch) {
        NSString *widthString =
            [params substringWithRange:[widthMatch rangeAtIndex:1]];
        imageData.width = [widthString floatValue];
      }

      NSRegularExpression *heightRegex = [NSRegularExpression
          regularExpressionWithPattern:@"height=\"([0-9.]+)\""
                               options:0
                                 error:nil];
      NSTextCheckingResult *heightMatch =
          [heightRegex firstMatchInString:params
                                  options:0
                                    range:NSMakeRange(0, params.length)];

      if (heightMatch) {
        NSString *heightString =
            [params substringWithRange:[heightMatch rangeAtIndex:1]];
        imageData.height = [heightString floatValue];
      }

      stylePair.styleValue = imageData;
    } else if ([tagName isEqualToString:@"u"]) {
      [styleArr addObject:@([UnderlineStyle getStyleType])];
    } else if ([tagName isEqualToString:@"s"]) {
      [styleArr addObject:@([StrikethroughStyle getStyleType])];
    } else if ([tagName isEqualToString:@"font"]) {
      [styleArr addObject:@([ColorStyle getStyleType])];

      NSString *pattern = @"color=\"([^\"]+)\"";
      NSRegularExpression *regex =
          [NSRegularExpression regularExpressionWithPattern:pattern
                                                    options:0
                                                      error:nil];
      NSTextCheckingResult *match =
          [regex firstMatchInString:params
                            options:0
                              range:NSMakeRange(0, params.length)];

      if (match.numberOfRanges == 2) {
        NSString *colorString =
            [params substringWithRange:[match rangeAtIndex:1]];

        UIColor *color = [UIColor colorFromString:colorString];
        if (color == nil) {
          continue;
        }

        stylePair.styleValue = color;
      }
    } else if ([tagName isEqualToString:@"code"]) {
      [styleArr addObject:@([InlineCodeStyle getStyleType])];
    } else if ([tagName isEqualToString:@"a"]) {
      NSRegularExpression *hrefRegex =
          [NSRegularExpression regularExpressionWithPattern:@"href=\".+\""
                                                    options:0
                                                      error:nullptr];
      NSTextCheckingResult *match =
          [hrefRegex firstMatchInString:params
                                options:0
                                  range:NSMakeRange(0, params.length)];

      if (match == nullptr) {
        // same as on Android, no href (or empty href) equals no link style
        continue;
      }

      NSRange hrefRange = match.range;
      [styleArr addObject:@([LinkStyle getStyleType])];
      // cut only the url from the href="..." string
      NSString *url =
          [params substringWithRange:NSMakeRange(hrefRange.location + 6,
                                                 hrefRange.length - 7)];
      stylePair.styleValue = url;
    } else if ([tagName isEqualToString:@"mention"]) {
      [styleArr addObject:@([MentionStyle getStyleType])];
      // extract html expression into dict using some regex
      NSMutableDictionary *paramsDict = [[NSMutableDictionary alloc] init];
      NSString *pattern = @"(\\w+)=\"([^\"]*)\"";
      NSRegularExpression *regex =
          [NSRegularExpression regularExpressionWithPattern:pattern
                                                    options:0
                                                      error:nil];

      [regex enumerateMatchesInString:params
                              options:0
                                range:NSMakeRange(0, params.length)
                           usingBlock:^(NSTextCheckingResult *_Nullable result,
                                        NSMatchingFlags flags,
                                        BOOL *_Nonnull stop) {
                             if (result.numberOfRanges == 3) {
                               NSString *key = [params
                                   substringWithRange:[result rangeAtIndex:1]];
                               NSString *value = [params
                                   substringWithRange:[result rangeAtIndex:2]];
                               paramsDict[key] = value;
                             }
                           }];

      MentionParams *mentionParams = [[MentionParams alloc] init];
      mentionParams.text = paramsDict[@"text"];
      mentionParams.indicator = paramsDict[@"indicator"];

      [paramsDict removeObjectsForKeys:@[ @"text", @"indicator" ]];
      NSError *error;
      NSData *attrsData = [NSJSONSerialization dataWithJSONObject:paramsDict
                                                          options:0
                                                            error:&error];
      NSString *formattedAttrsString =
          [[NSString alloc] initWithData:attrsData
                                encoding:NSUTF8StringEncoding];
      mentionParams.attributes = formattedAttrsString;

      stylePair.styleValue = mentionParams;
    } else if ([tagName isEqualToString:@"hr"]) {
      [styleArr addObject:@([DividerStyle getStyleType])];
    } else if ([tagName isEqualToString:@"h1"]) {
      [styleArr addObject:@([H1Style getStyleType])];
    } else if ([tagName isEqualToString:@"h2"]) {
      [styleArr addObject:@([H2Style getStyleType])];
    } else if ([tagName isEqualToString:@"h3"]) {
      [styleArr addObject:@([H3Style getStyleType])];
    } else if ([tagName isEqualToString:@"h4"]) {
      [styleArr addObject:@([H4Style getStyleType])];
    } else if ([tagName isEqualToString:@"h5"]) {
      [styleArr addObject:@([H5Style getStyleType])];
    } else if ([tagName isEqualToString:@"h6"]) {
      [styleArr addObject:@([H6Style getStyleType])];
    } else if ([tagName isEqualToString:@"ul"]) {
      [styleArr addObject:@([UnorderedListStyle getStyleType])];
    } else if ([tagName isEqualToString:@"ol"]) {
      [styleArr addObject:@([OrderedListStyle getStyleType])];
    } else if ([tagName isEqualToString:@"blockquote"]) {
      [styleArr addObject:@([BlockQuoteStyle getStyleType])];
    } else if ([tagName isEqualToString:@"codeblock"]) {
      [styleArr addObject:@([CodeBlockStyle getStyleType])];
    } else if ([tagName isEqualToString:@"checklist"]) {
      [styleArr addObject:@([CheckBoxStyle getStyleType])];

      BOOL checked = NO;

      if (params.length > 0) {
        NSRegularExpression *checkedRegex = [NSRegularExpression
            regularExpressionWithPattern:@"checked\\s*=\\s*(['\"])(.*?)\\1"
                                 options:NSRegularExpressionCaseInsensitive
                                   error:nil];

        NSTextCheckingResult *match =
            [checkedRegex firstMatchInString:params
                                     options:0
                                       range:NSMakeRange(0, params.length)];

        if (match && match.numberOfRanges >= 3) {
          NSString *valueStr =
              [params substringWithRange:[match rangeAtIndex:2]];
          valueStr = valueStr.lowercaseString;

          checked = [valueStr isEqualToString:@"true"] ||
                    [valueStr isEqualToString:@"yes"] ||
                    [valueStr isEqualToString:@"1"];
        }
      }

      stylePair.styleValue = @(checked);
    } else if ([tagName isEqualToString:@"content"]) {
      [styleArr addObject:@([ContentStyle getStyleType])];

      NSMutableDictionary *paramsDict = [[NSMutableDictionary alloc] init];
      NSString *pattern = @"(\\w+)=\"([^\"]*)\"";
      NSRegularExpression *regex =
          [NSRegularExpression regularExpressionWithPattern:pattern
                                                    options:0
                                                      error:nil];

      [regex enumerateMatchesInString:params
                              options:0
                                range:NSMakeRange(0, params.length)
                           usingBlock:^(NSTextCheckingResult *_Nullable result,
                                        NSMatchingFlags flags,
                                        BOOL *_Nonnull stop) {
                             if (result.numberOfRanges == 3) {
                               NSString *key = [params
                                   substringWithRange:[result rangeAtIndex:1]];
                               NSString *value = [params
                                   substringWithRange:[result rangeAtIndex:2]];
                               paramsDict[key] = value;
                             }
                           }];

      ContentParams *contentParams = [[ContentParams alloc] init];
      contentParams.text = paramsDict[@"text"] ?: @"";
      contentParams.type = paramsDict[@"type"] ?: @"";
      contentParams.url = paramsDict[@"src"] ?: @"";
      NSDictionary<NSString *, NSString *> *headers =
          [ContentParams parseHeaderFromString:paramsDict[@"headers"]];
      contentParams.headers = headers;

      [paramsDict removeObjectsForKeys:@[ @"text", @"type" ]];
      NSError *error;
      NSData *attrsData = [NSJSONSerialization dataWithJSONObject:paramsDict
                                                          options:0
                                                            error:&error];
      NSString *formattedAttrsString =
          [[NSString alloc] initWithData:attrsData
                                encoding:NSUTF8StringEncoding];
      contentParams.attributes = formattedAttrsString;
      stylePair.styleValue = contentParams;
    } else {
      // some other external tags like span just don't get put into the
      // processed styles
      continue;
    }

    stylePair.rangeValue = tagRangeValue;
    [styleArr addObject:stylePair];
    [processedStyles addObject:styleArr];
  }

  return @[ plainText, processedStyles ];
}

@end
